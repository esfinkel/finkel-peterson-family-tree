<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Finkel/Peterson Family Tree</title>
  <meta name="description" content="Family tree for the Finkel-Peterson family." />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Copyright 1998-2019 by Northwoods Software Corporation. -->

  <script src="go.js"></script>
  <script id="code">

    marriagesInfo = [{sA: -100, sB: -110, info: "married in 1900"}];

    // key needs to be different number for each person
    // n = name (must be in double quotes)
    // s (sex/gender) is either "M" or "F"
    // p1 is parent1 (should be that person's key)
    // p2 is parent2
    // ux is spouse's key
    // n: name, s: gender, m: mother, f: father, p1: parent1, p2: parent2, ux: spouse, a: attributes/markers
    familyInfo = [

// Patyk-Finkel

{ key: 1, n: "Leo Patyk-Finkel", s: "M", p1: 2, p2: 3, info: "Lives in Vermont" },
{ key: 2, n: "Lynn", s: "F", p1: 16, p2: 19, ux: 3, info: "Lives in Vermont, works at Dartmouth" },
{ key: 3, n: "Stu", s: "M", p1: 22, p2: 23,ux: 2, info: "Lives in Vermont, works at Dartmouth" },
{ key: 4, n: "Max", s: "M", p1: 2, p2: 3, info: "Lives in Colorado" },

// Finkel(Peterson)

{ key: 5, n: "Ellie", s: "F", p1: 6, p2: 7, info: "Lives in New York" },
{ key: 6, n: "Sue Peterson", s: "F", p1: 28, p2: 29, ux: 7, info: "Lives in Illinois, works at Northwestern Hospital" },
{ key: 7, n: "Ed", s: "M", p1: 22, p2: 23, ux: 6, info: "Lives in Illinois" },
{ key: 8, n: "Maddie", s: "F", p1: 6, p2: 7, info: "Lives in Illinois" },
{ key: 9, n: "Jake", s: "M", p1: 6, p2: 7, info: "Lives in Illinois" },

// Anders

{ key: 10, n: "Addie", s: "F", p1: 11, p2: 12, info: "Lives in Wisconsin" },
{ key: 11, n: "Laura", s: "F", p1: 16, p2: 19, ux: 12, info: "Live in Wisconsin" },
{ key: 12, n: "Jay", s: "M", ux: 11, info: "Lives in Wisconsin, works at Miller Beerl" },
{ key: 13, n: "Braden", s: "M", p1: 11, p2: 12, info: "Lives in  Wisconsin" },
{ key: 14, n: "Drew", s: "M", p1: 11, p2: 12, info: "Lives in Wisconsin" },

//Lisa(Patyk)
{ key: 15, n: "Lisa", s: "F", p1: 16, p2: 19, info: "Lives in Wisconsin" },

//Czarnecki Family

{key: 16, n: "Gloria Czarnecki" , s: "F", p1: 17, p2: 18, ux: 19 },
{key: 17, n: "Stella Smerlinsky" , s: "F", ux: 18 },
{key: 18, n: "Julian" , s: "M", ux: 17 },

//Patyk Family

{key: 19, n: "Gary" , s: "M", p1: 20, p2: 21, ux: 16 },
{key: 20, n: "Jean", s: "F", ux: 21 },
{key: 21, n: "???(Patyk)", s: "M", ux: 20 },

//Finkel(Richman)

{key: 22, n: "Fran", s: "F", p1: -1, p2: -28, ux:23, info: "Lives in Pennsylvania" },
{key: 23, n: "Larry", s: "M", p1: 38, p2: -33, ux: 22 },

//Manthey

{ key: 24, n: "Emma", s: "F", p1: 25, p2: 26, info: "Lives in Illinois" },
{ key: 25, n: "Catherine", s: "F", p1: 28, p2: 29, ux: 26, info: "Lives in Illinois" },
{ key: 26, n: "Jim Manthey", s: "M", ux: 25, info: "Lives in Illinois" },

//Dave Jr. Peterson

{ key: 27, n: "Dave Jr.", s: "M", p1: 28, p2: 29 },

// Peterson

{ key: 28,  n: "Rosalind", s: "F", ux: 29, info: "Lives in Illinois" },
{ key: 29, n: "Dave Sr.", s: "M", p1: -37, p2: -38, ux: 28, info: "Lives in Illinois" },

//Hunn

{ key: 30, n: "Ellen", s: "F", p1: 38, p2: -33, ux: 31 },
{ key: 31, n: "Ken Hunn", s: "M", ux: 30},
{ key: 32, n: "Brian", s: "M", p1: 30, p2: 31, ux: 33 },
{ key: 33, n: "Nicole", s: "F", ux: 32 },
{ key: "32a", n: "Bailey", s: "M", p1: 32, p2: 33 },
{ key: "32b", n: "Jonathan", s: "M", p1: 32, p2: 33 },
{ key: "32c", n: "Ava", s: "F", p1: 32, p2: 33 },
{ key: 34, n: "Eric", s: "M", p1: 30, p2: 31, ux: 35 },
{ key: 35, n: "Penny", s: "F", ux: 34 },
{ key: "37a", n: "Ethan", s: "M", p1: 34, p2: 35 },
{ key: "37b", n: "Lexi", s: "F", p1: 34, p2: 35 },
{ key: 37, n: "Matthew", s: "M", p1: 30, p2: 31 },

//Finkel

{ key: 38, n: "Samuel", s: "M", p1: 47, p2: 48 },
{ key: 39, n: "Cele Shulman", s: "F", ux: 38 },
{ key: 46, n: "Evelyn Kabatznick", s: "F", ux: 38 },
{ key: 47, n: "Max Finkel", s: "M", ux: 36 },
{ key: 36, n: "Yetta", s: "F", ux: 47 },
{ key: "47a", n: "Solomon?", s: "M", p1: 47, p2: 48 },
{ key: "47b", n: "Ethel", s: "F", p1: 47, p2: 48 },
{ key: "47ba", n: "Lou Brandow", s: "M", ux: "47b" },
{ key: "47bb", n: "David Trusell", s: "M", ux: "47b" },
{ key: "47bc", n: "Jack", s: "M", p1: "47b", p2: "47bb" },

//Brody

{ key: 40, n: "Martha", s: "F", p1: 38, p2: 39, ux: 41 }, 
{ key: 41, n: "Arthur Brody", s: "M", ux: 40 },
{ key: 42, n: "Carl", s: "M", p1: 40, p2: 41, ux: 43 },
{ key: 43, n: "Becky", s: "F", ux: 42 },
	{ key: "42a", n: "Jill", s: "F", p1: 42, p2: 43 },
	{ key: "42b", n: "Robin", s: "F", p1: 42, p2: 43 },
{ key: 44, n: "Elissa", s: "F", p1: 40, p2: 41 },
{ key: 45, n: "Thomas", s: "M", p1: 44 },

//Slotkin(sub)

{ key: 48, n: "Evelyn", s: "F", p1: -34, p2: -35, ux: 49 },
{ key: 49, n: "Jack Rosen", s: "M", ux: 48 },
	{ key: "48a", s: "M", n: "Stanley", p1: 48, p2: 49 },
{ key: 50, n: "Sam", s: "M", p1: -34, p2: -35, ux: 51 },
{ key: 51, n: "Pauline", s: "F", ux: 50 }, 
	{ key: "50a", n: "Barry", s: "M", p1: 50, p2: 51 },
{ key: 52, n: "Marica", s: "F", p1: -34, p2: -35, ux: 53 },
{ key: 53, n: "Sam Skolnick", s: "M", ux: 52 },
{ key: "52a", n: "Jay", s: "M", p1: 52, p2: 53 },
{ key: "52b", n: "Harriet", s: "F", p1: 52, p2: 53 },


//Richman family
{ key: -1, n: "Samuel Richman", s: "M", p1: -2, p2: -7, ux: -28, info: "he was an 'upholder'" },
// W Pearl shur. married on March 11 1936
{ key: -2, n: "Louis", s: "M", p1: -3, p2: -4, ux: -7, info: "Louis Richman" },
{ key: -7, n: "Sara(h)", s: "F", p1: -8, p2: -9, ux: -2 },
// ‘Louis and Sara married in Philadelphia 1910?’ -FF
{ key: -3, n: "Isadore Rochman", s: "M", ux: -4, info: "Ize; ‘born in 1845 in Ochumunn, Russia. He married in 1865 and died in 1890 and was a jeweler’ - fran" },
{ key: -4, n: "Dora", s: "M", p1: -5, p2: -6, ux: -3, info: "nee Dora Sabilinsky." },
{ key: -5, n: "Goldie Kriv", s: "F", ux: -6, info: "1830-1895; probably born Ochumunn, Russia" },
{ key: -6, n: "Mushie Sabilinsky", s: "M", ux: -5 },
// m 1845
{ key: -8, n: "Ethel", s: "F", ux: -9, info: "(Anna Gvintz)(1859-1899)" },
{ key: -9, n: "Shumel Goodseit", s: "M", ux: -8, info: "(Gutzeit)(1855-1893) a teacher, might have lived in Odessa, Russia" },
{ key: -10, n: "Goldie", s: "F", p1: -2, p2: -7, ux: -14 },
{ key: -14, n: "Herman Ellisand", s: "M", ux: -10 },
	{ key: "-10a", n: "Harvey", s: "M", p1: -10, p2: -14 },
	{ key: "-10b", n: "Ivan", s: "M", p1: -10, p2: -14 },
{ key: -11, n: "Jean", s: "F", p1: -2, p2: -7, ux: -17 },
	{ key: -17, n: "Donald Schurr", s: "M", ux: -11 },
	{ key: "-11a", n: "Arnole", s: "M", p1: -11, p2: -17 },
	{ key: "-11b", n: "Steve", s: "M", p1: -11, p2: -17 },
{ key: -12, n: "Isadore", s: "M", p1: -2, p2: -7, ux: "-12c" },
	{ key: "-12c", n: "Sylvia", s: "F", ux: -12 },
	{ key: "-12a", n: "Steven", s: "M", p1: -12, p2: "-12c" },
	{ key: "-12b", n: "Devorah", s: "F", p1: -12, p2: "-12c" },
{ key: -13, n: "Martin", s: "M", p1: -2, p2: -7, ux: "-13c" },
	{ key: "-13c", n: "Mildren", s: "F", ux: -13 },
	{ key: "-13a", n: "Andy", s: "M", p1: -13, p2: "-13c" },
	{ key: "-13b", n: "Sharon", s: "F", p1: -13, p2: "-13c", info: "'Cousin Sharon'" },

{ key: -18, n: "Israel", s: "M", p1: -3, p2: -4, ux: "-18s" },
{ key: "-18s", n: "Anna", s: "F", ux: -18 },
{ key: -19, n: "Izzie", s: "X", p1: -3, p2: -4, ux: "-19s" },
{ key: "-19s", n: "Cele", s: "X", ux: -19 },
{ key: "-19a", n: "Goldie, Herb, Victor", s: "X", p1: -19, p2: "-19s" },
{ key: -20, n: "Charles", s: "M", p1: -3, p2: -4, ux: "-20s" },
{ key: "-20s", n: "Sara", s: "F", ux: -20 },
{ key: -21, n: "Minsa", s: "F", p1: -3, p2: -4, ux: "-21s" },
{ key: "-21s", n: "Bruce Potack", s: "M", ux: -21 },
{ key: "-21a", n: "(about 6 children)", s: "X", p1: -19, p2: "-19s" },
{ key: -22, n: "Rose; Fruda", s: "F", p1: -3, p2: -4, info: "(Russia) [not sure what that means]" },
{ key: -23, n: "?", s: "X", p1: -3, p2: -4, info: "'Family lore says there were two other sisters who married officers in the Russian army and went to China.' -F.F." },

{ key: -24, n: "Reba", s: "F", p1: -8, p2: -9, ux: "-24s", info: "came to america after sara" },
{ key: "-24s", n: "Dave", s: "M", ux: -24 },
{ key: -25, n: "2 other boys", s: "X", p1: -8, p2: -9, info: "one of whom might have returned to russia" },
{ key: -26, n: "Sam", s: "M", p1: -8, p2: -9, ux: "-26s" },
{ key: "-26s", n: "Beatrice", s: "F", ux: -26 },
{ key: "-26b", n: "Hank; Cele; possibly two others", s: "X", p1: -26, p2: "-26s" },


{ key: -27, n: "Charles", s: "M", p1: -8, p2: -9 },



// Shur family

{ key: "?1a", n: "", s: "X", ux: "?1b" },
{ key: "?1b", n: "", s: "X", ux: "?1a" },	
{ key: -31, n: "Nathan", s: "M", p1: "?1a", p2: "?1b", ux: "-31s" },
{ key: "-31s", n: "", s: "F", ux: -31 },
	{ key: "-31b", n: "Jake", s: "M", p1: -31, p2: "-31s" },
{ key: -32, n: "Harry", s: "M",  p1: "?1a", p2: "?1b" },
{ key: -29, n: "Joseph Shur", s: "M", p1: "?1a", p2: "?1b", ux: -30, info: "" },
{ key: -30, n: "Esther", s: "F", ux: -29, info: "" },
// there is some marriage info for joseph and esther
{ key: -28, n: "Pearl Shur", s: "F", p1: -29, p2: -30, ux: -1, info: "she was a clerk" },
{ key: "-28a", n: "Harry", s: "M", p1: -29, p2: -30, ux: "-28as" },
{ key: "-28as", n: "Rose", s: "F", ux: "-28a" },
{ key: "-28aa", n: "Sharon & Stanley", s: "X", p1: "-28a", p2: "-28as" },
{ key: "-28b", n: "Rose", s: "F", p1: -29, p2: -30, ux: "-28bs" },
{ key: "-28bs", n: "Harry Olin", s: "M", ux: "-28b" },
{ key: "-28ba", n: "Marilyn, Alan, Gerry", s: "X", p1: "-28b", p2: "-28bs" },
{ key: "-28c", n: "Fanny", s: "F", p1: -29, p2: -30, ux: "-28cs" },
{ key: "-28cs", n: "Ben Jones", s: "M", ux: "-28c" },
{ key: "-28cc", n: "Donald", s: "M", p1: "-28c", p2: "-28cs" },
{ key: "-28d", n: "Edith", s: "F", p1: -29, p2: -30, ux: "-28ds" },
{ key: "-28ds", n: "Victor Powell", s: "M", ux: "-28d" },
{ key: "-28da", n: "Nina", s: "F", p1: "-28d", p2: "-28ds" },
{ key: "-28db", n: "Eric", s: "M", p1: "-28d", p2: "-28ds" },




// Slotkin family

// Slotkin family immigrated from Vitebsk in 1906
{ key: "?2a", n: "?", s: "X", ux: "?2b", info: "Slotkin family immigrated from Vitebsk in 1906" },
{ key: "?2b", n: "?", s: "X", ux: "?2a", info: "Slotkin family immigrated from Vitebsk in 1906" },
{ key: -33, n: "Edythe Slotkin", s: "F", p1: -34, p2: -35, ux: 38, info: "married 1935" },
// Edythe married 1935
{ key: -34, n: "David Slotkin", s: "M", p1: "?2a", p2: "?2b", ux: -35 },
{ key: -35, n: "Leah Pearlstein", s: "F", ux: -34, info: "'probably born in Vitebsk, married and came here in 1906' - fran" },
// david and leah "married and came here in 1906" - fran
{ key: "-36a", n: "Max", s: "M", p1: "?2a", p2: "?2b", ux: "-36as" },
{ key: "-36as", n: "Frieda", s: "F", ux: "-36a" },
{ key: "-36ab", n: "Herman, Sam, Sol, Celia, Ester", s: "X", p1: "-36a", p2: "-36as" },
{ key: "-36b", n: "Cy", s: "M", p1: "?2a", p2: "?2b", ux: "-36bs" },
	{ key: "-36bs", n: "?", s: "F", ux: "-36b" },
{ key: "-36bb", n: "Lillian", s: "F", p1: "-36b", p2: "-36bs", ux: "-36bbs" },
	{ key: "-36bbs", n: "Bennet", s: "M", ux: "-36bb" },
	{ key: "-36bbb", n: "Valerie", s: "F", p1: "-36bb", p2: "-36bbs" },
	{ key: "-36bbc", n: "Stephanie", s: "F", p1: "-36bb", p2: "-36bbs" },
{ key: "-36bc", n: "Bennet", s: "M", p1: "-36b", p2: "-36bs" },



// Peterson/Walker family
{ key: -37, n: "Trellis Peterson", s: "M", ux: -38, info: "'Was from Kansas... Supervisor for Silver Cup Bread... Worked for Holsum Bread... Painted the insides of people's homes to support his family' -R Peterson" },
{ key: -38, n: "Lillian Walker", s: "F", ux: -37 },










];


    
    function init() {
      var $ = go.GraphObject.make;
      myDiagram =
      $(go.Diagram, "myDiagramDiv",
      {
        initialAutoScale: go.Diagram.Uniform,
        "undoManager.isEnabled": true,
        // when a node is selected, draw a big yellow circle behind it  // handle clicking/highlighting
        nodeSelectionAdornmentTemplate:
        $(go.Adornment, "Auto",
        { layerName: "Grid" },  // the predefined layer that is behind everything else
        $(go.Shape, "Circle", { fill: "yellow", stroke: null }),
        $(go.Placeholder)
        ),
        layout:  // use a custom layout, defined below
        $(GenogramLayout, { direction: 90, layerSpacing: 30, columnSpacing: 10 })
      });
      
      function showMessage(h, m) {
        document.getElementById("diagramEventsMsgHeader").textContent = h;
        document.getElementById("diagramEventsMsgMsg").textContent = m;
      }
      
      function theyAreMarried(s1, s2) {
        return (s1.hasOwnProperty('ux') && s1.ux==s2.key) || (s2.hasOwnProperty('ux') && s2.ux==s1.key);
      }

      myDiagram.addDiagramListener("ObjectSingleClicked",
        function(e) { 
          var part = e.subject.part;
          var head = "";
          var msg = "";

          if (part instanceof go.Link) {
            const pair = familyInfo.filter(d => d.key==part.fromNode.key || d.key==part.toNode.key);
            var from = pair[0];
            var to = pair[1];

            if (theyAreMarried(from, to)) {
              const arr1 = marriagesInfo.filter(d => (d.sA==from.key && d.sB==to.key) || (d.sB==from.key && d.sA==to.key));
              if (arr1.length==1) {
                head = "Info for marriage between "+from.n+" and "+to.n+":";
                msg = arr1[0].info;
              } else if (arr1.length==0) {
                msg = "No additional info for marriage between "+from.n+" and "+to.n+".";
              } else {
                msg = "Err: multiple matching marriages";
              }
            }
          }

          else { // if node
            if (part.data.hasOwnProperty("info")) {
              head = "Info:";
              msg = part.data.info;
            } else {
              msg = "No additional info on this person.";
            }
          }

          showMessage(head, msg);
        
      }); 
      
      // allow message to disappear when item is deselected 
      myDiagram.addDiagramListener("BackgroundSingleClicked",
        function(e) {
          showMessage("", "");
      }); 
      myDiagram.addDiagramListener("BackgroundDoubleClicked",
        function(e) {
          showMessage("", "");
      }); 
      myDiagram.addDiagramListener("BackgroundContextClicked",
        function(e) {
          showMessage("", "");
      }); 


      

      //   // determine the color/geometry for each attribute shape
      var tlsq = go.Geometry.parse("F M1 1 l19 0 0 19 -19 0z");
      function maleGeometry(a) {
        return tlsq;
      }
      function femaleGeometry(a) {
        return tlsq;
      }
      function xGeometry(a) {
          return tlsq;
      }


    // 3 different node templates, based on gender,
      // named by the category value in the node data object
      myDiagram.nodeTemplateMap.add("M",  // male
        $(go.Node, "Vertical",
          { locationSpot: go.Spot.Center, locationObjectName: "ICON" },
          $(go.Panel,
            { name: "ICON" },
            $(go.Shape, "Square",
              { width: 40, height: 40, strokeWidth: 2, fill: "white", portId: "" }),
            $(go.Panel,
              { // for each attribute show a Shape at a particular place in the overall square
                itemTemplate:
                  $(go.Panel,
                    $(go.Shape,
                      { stroke: null, strokeWidth: 0 },
                    //   new go.Binding("fill", "", attrFill),
                      new go.Binding("geometry", "", maleGeometry))
                  ),
                margin: 1
              },
              new go.Binding("itemArray", "a")
            )
          ),
          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n"))
        ));
      myDiagram.nodeTemplateMap.add("F",  // female
        $(go.Node, "Vertical",
          { locationSpot: go.Spot.Center, locationObjectName: "ICON" },
          $(go.Panel,
            { name: "ICON" },
            $(go.Shape, "Triangle",
              { width: 40, height: 40, strokeWidth: 2, fill: "white", portId: "" }),
            $(go.Panel,
              { // for each attribute show a Shape at a particular place in the overall circle
                itemTemplate:
                  $(go.Panel,
                    $(go.Shape,
                      { stroke: null, strokeWidth: 0 },
                    //   new go.Binding("fill", "", attrFill),
                      new go.Binding("geometry", "", femaleGeometry))
                  ),
                margin: 1
              },
              new go.Binding("itemArray", "a")
            )
          ),
          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n"))
        ));
        myDiagram.nodeTemplateMap.add("X",  // other
        $(go.Node, "Vertical",
          { locationSpot: go.Spot.Center, locationObjectName: "ICON" },
          $(go.Panel,
            { name: "ICON" },
            $(go.Shape, "Diamond",
              { width: 40, height: 40, strokeWidth: 2, fill: "white", portId: "" }),
            $(go.Panel,
              { // for each attribute show a Shape at a particular place in the overall circle
                itemTemplate:
                  $(go.Panel,
                    $(go.Shape,
                      { stroke: null, strokeWidth: 0 },
                    //   new go.Binding("fill", "", attrFill),
                      new go.Binding("geometry", "", xGeometry))
                  ),
                margin: 1
              },
              new go.Binding("itemArray", "a")
            )
          ),
          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n"))
        ));
        myDiagram.nodeTemplateMap.add("P",  // other
        $(go.Node, "Vertical",
          { locationSpot: go.Spot.Center, locationObjectName: "ICON" },
          $(go.Panel,
            { name: "ICON" },
            $(go.Shape, "Circle",
              { width: 40, height: 40, strokeWidth: 2, fill: "white", portId: "" }),
            $(go.Panel,
              { // for each attribute show a Shape at a particular place in the overall circle
                itemTemplate:
                  $(go.Panel,
                    $(go.Shape,
                      { stroke: null, strokeWidth: 0 },
                    //   new go.Binding("fill", "", attrFill),
                      new go.Binding("geometry", "", xGeometry))
                  ),
                margin: 1
              },
              new go.Binding("itemArray", "a")
            )
          ),
          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n"))
        ));



        // the representation of each label node -- nothing shows on a Marriage Link
      myDiagram.nodeTemplateMap.add("LinkLabel",
        $(go.Node, { selectable: false, width: 1, height: 1, fromEndSegmentLength: 20 }));
      myDiagram.linkTemplate =  // for parent-child relationships
        $(go.Link,
          {
            routing: go.Link.Orthogonal, curviness: 15,
            layerName: "Background", selectable: false,
            fromSpot: go.Spot.Bottom, toSpot: go.Spot.Top
          },
          $(go.Shape, { strokeWidth: 2 })
        );
      myDiagram.linkTemplateMap.add("Marriage",  // for marriage relationships
        $(go.Link,
          {
            selectable: true
            // ,routing: go.Link.AvoidsNodes
          },
          $(go.Shape, { strokeWidth: 10, stroke: "blue" })
        ));

      setupDiagram(myDiagram, familyInfo, 4 /* focus on this person */);
    }
    
    // create and initialize the Diagram.model given an array of node data representing people
    function setupDiagram(diagram, array, focusId) {
      diagram.model =
        go.GraphObject.make(go.GraphLinksModel,
          { // declare support for link label nodes
            linkLabelKeysProperty: "labelKeys",
            // this property determines which template is used
            nodeCategoryProperty: "s",
            // if a node data object is copied, copy its data.a Array
            copiesArrays: true,
            // create all of the nodes for people
            nodeDataArray: array
          });
      setupMarriages(diagram);
      setupParents(diagram);
      // var node = diagram.findNodeForKey(focusId);  // autoselect a node upon load
      // if (node !== null) {                                  
      //   diagram.select(node);
      // }
    }
    function findMarriage(diagram, a, b) {  // A and B are node keys
      var nodeA = diagram.findNodeForKey(a);
      var nodeB = diagram.findNodeForKey(b);
      if (nodeA !== null && nodeB !== null) {
        var it = nodeA.findLinksBetween(nodeB);  // in either direction
        while (it.next()) {
          var link = it.value;
          // Link.data.category === "Marriage" means it's a marriage relationship
          if (link.data !== null && link.data.category === "Marriage") return link;
        }
      }
      return null;
    }
    // now process the node data to determine marriages
    function setupMarriages(diagram) {
      var model = diagram.model;
      var nodeDataArray = model.nodeDataArray;
      for (var i = 0; i < nodeDataArray.length; i++) {
        var data = nodeDataArray[i];
        var key = data.key;
        var uxs = data.ux;
        if (uxs !== undefined) {
          if (typeof uxs === "number" || typeof uxs === "string") uxs = [uxs];
          for (var j = 0; j < uxs.length; j++) {
            var wife = uxs[j];
            if (key === wife) {
              // or warn no reflexive marriages
              continue;
            }
            var link = findMarriage(diagram, key, wife);
            if (link === null) {
              // add a label node for the marriage link
              var mlab = { s: "LinkLabel" };
              model.addNodeData(mlab);
              // add the marriage link itself, also referring to the label node
              var mdata = { from: key, to: wife, labelKeys: [mlab.key], category: "Marriage" };
              model.addLinkData(mdata);
            }
          }
        }
      }
    }
    // process parent-child relationships once all marriages are known
    function setupParents(diagram) {
      var model = diagram.model;
      var nodeDataArray = model.nodeDataArray;
      for (var i = 0; i < nodeDataArray.length; i++) {
        var data = nodeDataArray[i];
        var key = data.key;
        var p1 = data.p1;
        var p2 = data.p2;
        if (p1 == undefined && p2 == undefined) {
            p1 = data.m;
            p2 = data.f;
        }
        if (p1 !== undefined && p2 !== undefined) {
          var link = findMarriage(diagram, p1, p2);
          if (link === null) {
            // or warn no known mother or no known father or no known marriage between them
            if (window.console) window.console.log("unknown marriage: " + p1 + " & " + p2);
            continue;
          }
          var mdata = link.data;
          var mlabkey = mdata.labelKeys[0];
          var cdata = { from: mlabkey, to: key };
          myDiagram.model.addLinkData(cdata);
        }
      }
    }
    // A custom layout that shows the two families related to a person's parents
    function GenogramLayout() {
      go.LayeredDigraphLayout.call(this);
      this.initializeOption = go.LayeredDigraphLayout.InitDepthFirstIn;
      this.spouseSpacing = 30;  // minimum space between spouses
    }
    go.Diagram.inherit(GenogramLayout, go.LayeredDigraphLayout);
    GenogramLayout.prototype.makeNetwork = function(coll) {
      // generate LayoutEdges for each parent-child Link
      var net = this.createNetwork();
      if (coll instanceof go.Diagram) {
        this.add(net, coll.nodes, true);
        this.add(net, coll.links, true);
      } else if (coll instanceof go.Group) {
        this.add(net, coll.memberParts, false);
      } else if (coll.iterator) {
        this.add(net, coll.iterator, false);
      }
      return net;
    };
    // internal method for creating LayeredDigraphNetwork where husband/wife pairs are represented
    // by a single LayeredDigraphVertex corresponding to the label Node on the marriage Link
    GenogramLayout.prototype.add = function(net, coll, nonmemberonly) {
      var multiSpousePeople = new go.Set();
      // consider all Nodes in the given collection
      var it = coll.iterator;
      while (it.next()) {
        var node = it.value;
        if (!(node instanceof go.Node)) continue;
        if (!node.isLayoutPositioned || !node.isVisible()) continue;
        if (nonmemberonly && node.containingGroup !== null) continue;
        // if it's an unmarried Node, or if it's a Link Label Node, create a LayoutVertex for it
        if (node.isLinkLabel) {
          // get marriage Link
          var link = node.labeledLink;
          var spouseA = link.fromNode;
          var spouseB = link.toNode;
          // create vertex representing both husband and wife
          var vertex = net.addNode(node);
          // now define the vertex size to be big enough to hold both spouses
          vertex.width = spouseA.actualBounds.width + this.spouseSpacing + spouseB.actualBounds.width;
          vertex.height = Math.max(spouseA.actualBounds.height, spouseB.actualBounds.height);
          vertex.focus = new go.Point(spouseA.actualBounds.width + this.spouseSpacing / 2, vertex.height / 2);
        } else {
          // don't add a vertex for any married person!
          // instead, code above adds label node for marriage link
          // assume a marriage Link has a label Node
          var marriages = 0;
          node.linksConnected.each(function(l) { if (l.isLabeledLink) marriages++; });
          if (marriages === 0) {
            var vertex = net.addNode(node);
          } else if (marriages > 1) {
            multiSpousePeople.add(node);
          }
        }
      }
      // now do all Links
      it.reset();
      while (it.next()) {
        var link = it.value;
        if (!(link instanceof go.Link)) continue;
        if (!link.isLayoutPositioned || !link.isVisible()) continue;
        if (nonmemberonly && link.containingGroup !== null) continue;
        // if it's a parent-child link, add a LayoutEdge for it
        if (!link.isLabeledLink) {
          var parent = net.findVertex(link.fromNode);  // should be a label node
          var child = net.findVertex(link.toNode);
          if (child !== null) {  // an unmarried child
            net.linkVertexes(parent, child, link);
          } else {  // a married child
            link.toNode.linksConnected.each(function(l) {
              if (!l.isLabeledLink) return;  // if it has no label node, it's a parent-child link
              // found the Marriage Link, now get its label Node
              var mlab = l.labelNodes.first();
              // parent-child link should connect with the label node,
              // so the LayoutEdge should connect with the LayoutVertex representing the label node
              var mlabvert = net.findVertex(mlab);
              if (mlabvert !== null) {
                net.linkVertexes(parent, mlabvert, link);
              }
            });
          }
        }
      }
      while (multiSpousePeople.count > 0) {
        // find all collections of people that are indirectly married to each other
        var node = multiSpousePeople.first();
        var cohort = new go.Set();
        this.extendCohort(cohort, node);
        // then encourage them all to be the same generation by connecting them all with a common vertex
        var dummyvert = net.createVertex();
        net.addVertex(dummyvert);
        var marriages = new go.Set();
        cohort.each(function(n) {
          n.linksConnected.each(function(l) {
            marriages.add(l);
          })
        });
        marriages.each(function(link) {
          // find the vertex for the marriage link (i.e. for the label node)
          var mlab = link.labelNodes.first()
          var v = net.findVertex(mlab);
          if (v !== null) {
            net.linkVertexes(dummyvert, v, null);
          }
        });
        // done with these people, now see if there are any other multiple-married people
        multiSpousePeople.removeAll(cohort);
      }
    };
    // collect all of the people indirectly married with a person
    GenogramLayout.prototype.extendCohort = function(coll, node) {
      if (coll.has(node)) return;
      coll.add(node);
      var lay = this;
      node.linksConnected.each(function(l) {
        if (l.isLabeledLink) {  // if it's a marriage link, continue with both spouses
          lay.extendCohort(coll, l.fromNode);
          lay.extendCohort(coll, l.toNode);
        }
      });
    };
    GenogramLayout.prototype.assignLayers = function() {
      go.LayeredDigraphLayout.prototype.assignLayers.call(this);
      var horiz = this.direction == 0.0 || this.direction == 180.0;
      // for every vertex, record the maximum vertex width or height for the vertex's layer
      var maxsizes = [];
      this.network.vertexes.each(function(v) {
        var lay = v.layer;
        var max = maxsizes[lay];
        if (max === undefined) max = 0;
        var sz = (horiz ? v.width : v.height);
        if (sz > max) maxsizes[lay] = sz;
      });
      // now make sure every vertex has the maximum width or height according to which layer it is in,
      // and aligned on the left (if horizontal) or the top (if vertical)
      this.network.vertexes.each(function(v) {
        var lay = v.layer;
        var max = maxsizes[lay];
        if (horiz) {
          v.focus = new go.Point(0, v.height / 2);
          v.width = max;
        } else {
          v.focus = new go.Point(v.width / 2, 0);
          v.height = max;
        }
      });
      // from now on, the LayeredDigraphLayout will think that the Node is bigger than it really is
      // (other than the ones that are the widest or tallest in their respective layer).
    };
    GenogramLayout.prototype.commitNodes = function() {
      go.LayeredDigraphLayout.prototype.commitNodes.call(this);
      // position regular nodes
      this.network.vertexes.each(function(v) {
        if (v.node !== null && !v.node.isLinkLabel) {
          v.node.position = new go.Point(v.x, v.y);
        }
      });
      // position the spouses of each marriage vertex
      var layout = this;
      this.network.vertexes.each(function(v) {
        if (v.node === null) return;
        if (!v.node.isLinkLabel) return;
        var labnode = v.node;
        var lablink = labnode.labeledLink;
        // In case the spouses are not actually moved, we need to have the marriage link
        // position the label node, because LayoutVertex.commit() was called above on these vertexes.
        // Alternatively we could override LayoutVetex.commit to be a no-op for label node vertexes.
        lablink.invalidateRoute();
        var spouseA = lablink.fromNode;
        var spouseB = lablink.toNode;
        // // prefer fathers on the left, mothers on the right
        // if (spouseA.data.s === "F") {  // gender is female
        //   var temp = spouseA;
        //   spouseA = spouseB;
        //   spouseB = temp;
        // }
        // see if the parents are on the desired sides, to avoid a link crossing
        var aParentsNode = layout.findParentsMarriageLabelNode(spouseA);
        var bParentsNode = layout.findParentsMarriageLabelNode(spouseB);
        if (aParentsNode !== null && bParentsNode !== null && aParentsNode.position.x > bParentsNode.position.x) {
          // swap the spouses
          var temp = spouseA;
          spouseA = spouseB;
          spouseB = temp;
        }
        spouseA.position = new go.Point(v.x, v.y);
        spouseB.position = new go.Point(v.x + spouseA.actualBounds.width + layout.spouseSpacing, v.y);
        if (spouseA.opacity === 0) {
          var pos = new go.Point(v.centerX - spouseA.actualBounds.width / 2, v.y);
          spouseA.position = pos;
          spouseB.position = pos;
        } else if (spouseB.opacity === 0) {
          var pos = new go.Point(v.centerX - spouseB.actualBounds.width / 2, v.y);
          spouseA.position = pos;
          spouseB.position = pos;
        }
      });
      // position only-child nodes to be under the marriage label node
      this.network.vertexes.each(function(v) {
        if (v.node === null || v.node.linksConnected.count > 1) return;
        var mnode = layout.findParentsMarriageLabelNode(v.node);
        if (mnode !== null && mnode.linksConnected.count === 1) {  // if only one child
          var mvert = layout.network.findVertex(mnode);
          var newbnds = v.node.actualBounds.copy();
          newbnds.x = mvert.centerX - v.node.actualBounds.width / 2;
          // see if there's any empty space at the horizontal mid-point in that layer
          var overlaps = layout.diagram.findObjectsIn(newbnds, function(x) { return x.part; }, function(p) { return p !== v.node; }, true);
          if (overlaps.count === 0) {
            v.node.move(newbnds.position);
          }
        }
      });
    };
    GenogramLayout.prototype.findParentsMarriageLabelNode = function(node) {
      var it = node.findNodesInto();
      while (it.next()) {
        var n = it.value;
        if (n.isLinkLabel) return n;
      }
      return null;
    };
    // end GenogramLayout class
  </script>
</head>
<body onload="init()">
<div id="sample">
  <div id="myDiagramDiv" style="border: solid 2px black; width:100%; height:800px"></div>
  <div id="diagramEventsMsg">
    <strong><p id = "diagramEventsMsgHeader" style></p></strong>
    <p id = "diagramEventsMsgMsg"></p>
  </div>
  <form action="https://forms.gle/6bpb4cXdFc5j4zcm8">
    <button type="submit">Request addition/modification of data</button>
 </form>  
  <button value="Refresh Page" onClick="window.location.reload();">Refresh page</button>
  <div>Click on a name or marriage link to see extra info!</div>
</div>
</body>
</html>